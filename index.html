<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Multiple Wind Forecasts (Collapsible)</title>
  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/showdown/dist/showdown.min.js"></script>
  
  <style>
    
    body {
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      color: #333;
      line-height: 1.6;
      transition: background-color 0.3s, color 0.3s;
    }

    body.dark-mode {
      background-color: #202020;
      color: #e0e0e0;
    }

    header {
      background: linear-gradient(90deg, #bebebe, #bb92fd);
      color: #fff;
      padding: 20px 10%;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    header h1 {
      margin: 0;
      font-size: 2rem;
    }

    header p {
      margin: 10px 0 0;
      font-size: 1rem;
    }

    details {
      margin: 10px 10px;
      padding: 10px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
      transition: background-color 0.3s, color 0.3s;
      
    }

    details summary {
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      margin-bottom: 5px;
    }

    .chart-container {
      margin-top: 15px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
      justify-content: center;
      align-items: center;
    }

    .controls-label {
      margin-right: 1rem;
      
    }

    .controls-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .slider-container {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
      justify-content: center;
      align-items: center;
    }

    .wrapper {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    
    body.dark-mode details {
      background: #333;
      border-color: #555;
      color: #e0e0e0;
    }

    #disclaimer {
      font-size: 0.9rem;
      text-align: center;
      margin-top: 40px;
      padding: 10px;
      background: #f8f9fa;
      border-top: 1px solid #ddd;
      transition: background-color 0.3s, color 0.3s;
    }

    body.dark-mode #disclaimer {
      background: #333;
      color: #e0e0e0;
      border-color: #555;
    }

    #disclaimer a {
      color: #007BFF;
      text-decoration: none;
    }

    body.dark-mode #disclaimer a {
      color: #66b2ff;
    }

    #disclaimer a:hover {
      text-decoration: underline;
    }

    #github-logo-container {
      text-align: center;
      margin-top: 10px;
    }

    #github-logo {
      width: 40px;
      height: 40px;
    }

    #source-code-text {
      text-align: center;
      margin-top: 10px;
    }

    #source-code-text a {
      color: #007BFF;
      text-decoration: none;
      font-weight: bold;
    }

    body.dark-mode #source-code-text a {
      color: #66b2ff;
    }

    #source-code-text a:hover {
      text-decoration: underline;
    }

    .settings-frame {
      text-align: center;
      margin: 10px 0;
    }

    .settings-frame input {
      margin-left: 10px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    table th, table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }

    table th {
      background-color: #f4f4f4;
      color: #333;
    }

    body.dark-mode table th {
      background-color: #444;
      color: #e0e0e0;
    }

    body.dark-mode table td {
      border-color: #555;
    }

  </style>
</head>

<body class="dark-mode">

  <header>
    <h1>German Energy Market Predictive Analytics</h1>
    <p>Explore detailed forecasts and insights into the energy market.</p>
    <p>Forecasts are updated daily using the latest data. 
      For the source code and method description see <div id="source-code-text">
        <a href="https://github.com/vsevolodnedora/energy_market_analysis" target="_blank">
          GitHub
        </a>
      </div>
    </p>
  </header>

  <div class="settings-frame">
    <label>
      <input type="checkbox" id="dark-mode-toggle" onchange="toggleDarkMode()"> Dark Mode
    </label>
  </div>

  <div id="error-message"></div>

  <!-- First chart collapsible -->
  <details open>
    <summary>Offshore Wind Power Forecast</summary>
    <div class="chart-container" id="chart1"></div>
  
    
    <div class="controls">
      <span class="controls-label">TSO Area:</span>
      <div class="controls-buttons">
        <label><input type="checkbox" id="50hz-checkbox-1" onchange="updateChart1()"> 50Hz</label>
        <label><input type="checkbox" id="tenn-checkbox-1" onchange="updateChart1()"> TenneT</label>
        <label><input type="checkbox" id="total-checkbox-1" checked onchange="updateChart1()"> Total</label>
      </div>
    </div>
    
    <div class="slider-container">
      <label for="past-data-slider-1">Amount of past data to show:</label>
      <input
        type="range"
        id="past-data-slider-1"
        min="1"
        max="100"
        step="1"
        value="20"
        onchange="updateChart1()"
      />
    </div>
  
    <details id="chart1-description-details">
      <summary>Show/Hide Description</summary>
      <div id="chart1-description-container">
        <!-- Markdown content will be dynamically loaded here -->
      </div>
    </details>
  </details>

  <!-- Second chart collapsible -->
  <details>
    <summary>Onshore Forecast (PLACEHOLDER)</summary>
    <div class="chart-container" id="chart2"></div>

    <div class="controls">
      <span class="controls-label">TSO Area:</span>
      <div class="controls-buttons">
        <label><input type="checkbox" id="50hz-checkbox-2" onchange="updateChart2()"> 50Hz</label>
        <label><input type="checkbox" id="tenn-checkbox-2" onchange="updateChart2()"> TenneT</label>
        <label><input type="checkbox" id="total-checkbox-2" checked onchange="updateChart2()"> Total</label>
      </div>
    </div>
    <div class="slider-container">
      <label for="past-data-slider-2">Amount of past data to show:</label>
      <input
        type="range"
        id="past-data-slider-2"
        min="1"
        max="100"
        step="1"
        value="20"
        onchange="updateChart2()"
      />
    </div>
  </details>

  <div id="disclaimer">
    Data sources: 
    <a href="https://transparency.entsoe.eu" target="_blank">ENTSO-E</a>, 
    <a href="https://www.smard.de/home" target="_blank">SMARD</a>, 
    <a href="https://open-meteo.com/" target="_blank">openmeteo</a>, 
    <a href="https://www.epexspot.com/en" target="_blank">EPEXSPOT</a>, 
    <a href="https://www.eex.com/en/" target="_blank">EEX</a>
  </div>

  <div id="github-logo-container">
    <a href="https://github.com/vsevolodnedora/energy_market_analysis" target="_blank">
      <img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Repo" id="github-logo">
    </a>
  </div>

  <!-- <div id="source-code-text">
    <a href="https://github.com/vsevolodnedora/energy_market_analysis" target="_blank">
      vsevolodnedora/energy_market_analysis
    </a>
  </div> -->
  <!-- =====================================| SCRIPT |=====================================  -->


  <script>
    
    baseUrl = "https://raw.githubusercontent.com/vsevolodnedora/energy_market_analysis/main/deploy/"

    let isDarkMode = true;

    // A helper to track whether each chart was created
    let chart1Created = false;
    let chart2Created = false;

    let chartInstance1 = null;
    let chartInstance2 = null;

    let chart1DescLoaded = false;
    let chart2DescLoaded = false;

    // Common chart options that can be reused
    function getBaseChartOptions() {
      return {
        chart: {
          type: 'line',
          height: 350,
          toolbar: { show: true }
        },
        series: [],
        xaxis: {
          type: 'datetime',
          labels: { style: { colors: isDarkMode ? '#e0e0e0' : '#000' } },
          title: { style: { color: isDarkMode ? '#e0e0e0' : '#000' } }
        },
        yaxis: {
          title: {
            text: 'Offshore Wind Power',
            style: { color: isDarkMode ? '#e0e0e0' : '#000' }
          },
          labels: { style: { colors: isDarkMode ? '#e0e0e0' : '#000' } }
        },
        annotations: { xaxis: [] },
        stroke: { width: 2 },

        tooltip: {
          shared: true,
          theme: isDarkMode ? 'dark' : 'light',
          x: { format: 'dd MMM yyyy HH:mm' }
        },
        legend: {
          labels: { colors: isDarkMode ? '#e0e0e0' : '#000', useSeriesColors: false }
        }
      };
    }

    // Listen for the toggle event on each <details> to create the chart if not already created
    document.querySelector('details:nth-of-type(1)').addEventListener('toggle', async function(e) {
      if (e.target.open && !chart1Created) {
        chart1Created = true;
        chartInstance1 = await createChart('#chart1');
        updateChart1(); // first update
      }
    });

    document.querySelector('details:nth-of-type(2)').addEventListener('toggle', async function(e) {
      if (e.target.open && !chart2Created) {
        chart2Created = true;
        chartInstance2 = await createChart('#chart2');
        updateChart2(); // first update
      }
    });

    // Listen for toggle on the chart #1 description details
    document .getElementById('chart1-description-details').addEventListener('toggle', async function (e) {
        // If the user is opening the details and it's not loaded yet...
        if (e.target.open && !chart1DescLoaded) {
            chart1DescLoaded = true;
            await loadMarkdown('data/forecasts/wind_offshore_notes.md', 'chart1-description-container');
        }
    });    

    // Helper function to load Markdown from a given URL, parse it, and insert into container
    async function loadMarkdown(url, containerId) {
        const fallbackUrl = baseUrl + url;
    
        try {
            // Attempt to fetch the file from the local path
            let response = await fetch(url);
    
            // If the response is not OK, throw an error to trigger the fallback
            if (!response.ok) {
                console.warn(`Failed to load markdown from local path: ${url}. Trying fallback URL.`);
                response = await fetch(fallbackUrl);
            }
    
            // If the fallback response is also not OK, throw an error
            if (!response.ok) {
                throw new Error(`Failed to load markdown from both local and fallback URLs.`);
            }
    
            const markdownText = await response.text();
    
            // Use showdown to convert the markdown to HTML
            const converter = new showdown.Converter({
                tables: true,
                ghCompatibleHeaderId: true,
                simplifiedAutoLink: true,
                strikethrough: true,
                tasklists: true,
                emoji: true,
                parseImgDimensions: true, // Parse image dimensions
                openLinksInNewWindow: true, // Open links in new tab
                simpleLineBreaks: true, // Treat single line breaks as <br>
            });
            const html = converter.makeHtml(markdownText);
    
            // Insert HTML into the container
            document.getElementById(containerId).innerHTML = html;
        } catch (error) {
            console.error(error);
            document.getElementById(containerId).innerHTML = `
                <p style="color:red;">
                    <strong>Error:</strong> Could not load description.
                </p>`;
        }
    }

    // If you want to destroy the chart on close to free memory, you can do so:
    // document.querySelector('details:nth-of-type(1)').addEventListener('toggle', function(e) {
    //   if (!e.target.open && chartInstance1) {
    //     chartInstance1.destroy();
    //     chartInstance1 = null;
    //     chart1Created = false;
    //   }
    // });

    // Create a new chart in a given container
    async function createChart(containerSelector) {
      const options = getBaseChartOptions();
      const newChart = new ApexCharts(document.querySelector(containerSelector), options);
      await newChart.render();
      return newChart;
    }


    // Helper color maps, etc., can be reused
    const colorMap = {
      'wind_offshore_50hz': '#1E90FF',
      'wind_offshore_tenn': '#FF6347',
      'wind_offshore': '#9370DB', // '#2E8B57'
    };

    const aliases = {
      'wind_offshore_50hz': '50Hz',
      'wind_offshore_tenn': 'TenneT',
      'wind_offshore': 'Total'
    };

    // Example update functions for each chart
    async function updateChart1() {
      if (!chartInstance1) return; // if chart not yet created

      document.getElementById('error-message').textContent = '';
      const seriesData = [];
      const annotations = [];

      // Grab controls
      const show50hz = document.getElementById('50hz-checkbox-1').checked;
      const showTenn = document.getElementById('tenn-checkbox-1').checked;
      const showTotal = document.getElementById('total-checkbox-1').checked;
      const pastDataRatio = document.getElementById('past-data-slider-1').value / 100;

      // Reuse the same logic you had for adding series
      async function addSeries(variable, pastFile, pastActualFile, currentFile, lowerFile, upperFile) {
        const baseColor = colorMap[variable];
        const alias = aliases[variable];

        const pastFittedData = await fetchData(variable, pastFile);
        const pastActualData = await fetchData(variable, pastActualFile);
        const currentData = await fetchData(variable, currentFile);
        const lowerData = await fetchData(variable, lowerFile);
        const upperData = await fetchData(variable, upperFile);

        if (pastFittedData) {
          const pastToShow = Math.floor(pastFittedData.length * pastDataRatio);
          seriesData.push({
            name: `${alias} (Past Fitted)`,
            data: pastFittedData.slice(-pastToShow),
            color: baseColor,
            type: 'line'
          });
        }

        if (pastActualData) {
          const pastToShow = Math.floor(pastActualData.length * pastDataRatio);
          seriesData.push({
            name: `${alias} (Past Actual)`,
            data: pastActualData.slice(-pastToShow),
            color: lightenColor(baseColor, 40),
            type: 'line',
            dashStyle: 'Dash'
          });
        }

        if (currentData) {
          seriesData.push({
            name: `${alias} (Current)`,
            data: currentData,
            color: baseColor,
            type: 'line'
          });
          if (currentData.length > 0) {
            annotations.push({
              x: currentData[0].x.getTime(),
              borderColor: '#808080',
              label: {
                text: 'Last Forecast',
                style: { color: '#FFFFFF', background: '#808080' }
              }
            });
          }
        }

        if (lowerData && upperData && lowerData.length === upperData.length) {
          const forecastPolygon = [
            ...lowerData.map((point) => ({ x: point.x, y: point.y })),
            ...upperData
              .slice()
              .reverse()
              .map((point) => ({ x: point.x, y: point.y }))
          ];
          if (forecastPolygon.length > 0) {
            seriesData.push({
              name: `${alias} (Forecast Interval)`,
              type: 'area',
              data: forecastPolygon,
              color: baseColor,
              fillOpacity: 0.3,
              showInLegend: true,
              fill: {
                type: 'gradient',
                gradient: {
                  shade: 'light',
                  type: 'vertical',
                  shadeIntensity: 0.4,
                  gradientToColors: [lightenColor(baseColor, 40), baseColor],
                  inverseColors: false,
                  opacityFrom: 0.4,
                  opacityTo: 0.4
                }
              }
            });
          }
        }
      }

      if (show50hz) {
        await addSeries(
          'wind_offshore_50hz',
          'forecast_prev_fitted.json',
          'forecast_prev_actual.json',
          'forecast_curr_fitted.json',
          'forecast_curr_lower.json',
          'forecast_curr_upper.json'
        );
      }
      if (showTenn) {
        await addSeries(
          'wind_offshore_tenn',
          'forecast_prev_fitted.json',
          'forecast_prev_actual.json',
          'forecast_curr_fitted.json',
          'forecast_curr_lower.json',
          'forecast_curr_upper.json'
        );
      }
      if (showTotal) {
        await addSeries(
          'wind_offshore',
          'forecast_prev_fitted.json',
          'forecast_prev_actual.json',
          'forecast_curr_fitted.json',
          'forecast_curr_lower.json',
          'forecast_curr_upper.json'
        );
      }

      // Example: add "Now" line
      const now = new Date();
      annotations.push({
        x: now.getTime(),
        borderColor: '#FF0000',
        label: { text: 'Now', style: { color: '#FFF', background: '#FF0000' } }
      });

      chartInstance1.updateOptions({
        series: seriesData,
        annotations: { xaxis: annotations },
        tooltip: { theme: isDarkMode ? 'dark' : 'light' },
        xaxis: {
          labels: { style: { colors: isDarkMode ? '#e0e0e0' : '#000' } },
          title: { style: { color: isDarkMode ? '#e0e0e0' : '#000' } }
        },
        yaxis: {
          title: {
            text: 'Offshore Wind Power',
            style: { 
              color: isDarkMode ? '#e0e0e0' : '#000',
              fontSize: '14px', // Optional, if not using CSS
              cssClass: 'custom-yaxis-title'
           }
          },
          labels: { style: { colors: isDarkMode ? '#e0e0e0' : '#000' } }
        },
        legend: {
          labels: { colors: isDarkMode ? '#e0e0e0' : '#000' }
        }
      });
    }

    async function updateChart2() {
      if (!chartInstance2) return; // if chart not yet created
      document.getElementById('error-message').textContent = '';
      const seriesData = [];
      const annotations = [];

      const show50hz = document.getElementById('50hz-checkbox-2').checked;
      const showTenn = document.getElementById('tenn-checkbox-2').checked;
      const showTotal = document.getElementById('total-checkbox-2').checked;
      const pastDataRatio = document.getElementById('past-data-slider-2').value / 100;

      // Reuse or adapt the same addSeries logic:
      async function addSeries(variable, pastFile, currentFile, lowerFile, upperFile) {
        // ... same logic as updateChart1
        // For brevity, you could create a shared function if the logic is exactly the same
      }

      // For demonstration, just do something simpler:
      if (show50hz) {
        // Example: push a dummy dataset
        seriesData.push({
          name: '50Hz (Dummy)',
          data: [
            { x: new Date(), y: Math.random() * 1000 },
            { x: new Date(Date.now() + 3600e3), y: Math.random() * 1000 }
          ],
          color: '#1E90FF'
        });
      }
      if (showTenn) {
        seriesData.push({
          name: 'TenneT (Dummy)',
          data: [
            { x: new Date(), y: Math.random() * 1000 },
            { x: new Date(Date.now() + 3600e3), y: Math.random() * 1000 }
          ],
          color: '#FF6347'
        });
      }
      if (showTotal) {
        seriesData.push({
          name: 'Total (Dummy)',
          data: [
            { x: new Date(), y: Math.random() * 1000 },
            { x: new Date(Date.now() + 3600e3), y: Math.random() * 1000 }
          ],
          color: '#2E8B57'
        });
      }

      annotations.push({
        x: new Date().getTime(),
        borderColor: '#FF0000',
        label: { text: 'Now', style: { color: '#FFF', background: '#FF0000' } }
      });

      chartInstance2.updateOptions({
        series: seriesData,
        annotations: { xaxis: annotations },
        tooltip: { theme: isDarkMode ? 'dark' : 'light' },
        xaxis: {
          labels: { style: { colors: isDarkMode ? '#e0e0e0' : '#000' } },
          title: { style: { color: isDarkMode ? '#e0e0e0' : '#000' } }
        },
        yaxis: {
          title: {
            text: 'Offshore Wind Power',
            style: {
              color: isDarkMode ? '#e0e0e0' : '#000',
              fontSize: '16px' // Adjust font size as needed
            }
          },
          labels: { style: { colors: isDarkMode ? '#e0e0e0' : '#000' } }
        },
        legend: {
          labels: { colors: isDarkMode ? '#e0e0e0' : '#000' }
        }
      });
    }


    // ----------------------------------------
    async function fetchData(variable, file) {
        try {
          const response = await fetch(`data/forecasts/${variable}/${file}`);
          if (!response.ok) throw new Error(`Failed to load ${variable}`);
          const data = await response.json();
          return data.map(([timestamp, value]) => ({ x: new Date(timestamp), y: value }));
        } catch (error) {
          document.getElementById('error-message').textContent = error.message;
          return null;
        }
    }
    
    function toggleDarkMode() {
        const body = document.body;
        body.classList.toggle('dark-mode');
        isDarkMode = !isDarkMode;
  
        // If charts exist, refresh them
        if (chartInstance1) updateChart1();
        if (chartInstance2) updateChart2();
    }
    
    function lightenColor(color, percent) {
        const num = parseInt(color.slice(1), 16),
          amt = Math.round(2.55 * percent),
          R = (num >> 16) + amt,
          G = (num >> 8 & 0x00FF) + amt,
          B = (num & 0x0000FF) + amt;
        return `#${(0x1000000 +
          (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
          (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 +
          (B < 255 ? (B < 1 ? 0 : B) : 255)
        ).toString(16).slice(1).toUpperCase()}`;
      }
    
      toggleDarkMode();
  
  </script>

    
</body>
</html>
